unit Aurelius.Sql.AbsoluteDB;

{$I Aurelius.inc}

interface

uses
  DB,
  Aurelius.Sql.AnsiSqlGenerator,
  Aurelius.Sql.BaseTypes,
  Aurelius.Sql.Commands,
  Aurelius.Sql.Interfaces,
  Aurelius.Sql.Register,
  Aurelius.Global.Utils,
  Variants,
  SysUtils,
  Generics.Collections;

type
  TAbsoluteDBSQLGenerator = class(TAnsiSQLGenerator)
  protected
    function GetMaxConstraintNameLength: Integer; override;
    function FieldTypeToSQL(FieldDef: TSQLFieldDefinition): string; override;
    function GetGeneratorName: string; override;
    function GetSqlDialect: string; override;
    function GenerateCreateTable(Command: TCreateTableCommand): string; override;
    function GenerateGetLastInsertId(SQLField: TSQLField): string; override;
    function GenerateLimitedSelect(SelectSql: TSelectSql; Command: TSelectCommand): string;
      override;
    // Disable/Enable foreign keys (even if Absolute Database has no foreign keys!)
    function GenerateEnableForeignKeys(Command: TEnableForeignKeysCommand): string; override;
    function GeneratePrimaryKey(APkName: string; AFields: TList<string>): string; override;
    function GenerateUniqueKeyDefinition(Command: TCreateUniqueKeyCommand): string; override;
    function GetSupportedFeatures: TDBFeatures; override;
    function GetSupportedFieldTypes: TFieldTypeSet; override;
  private
  end;

implementation

const
  NULL_SQL_COMMAND = 'DROP TABLE IF EXISTS MEMORY "";'; // a placeholder NULL command (see explanations below)

{ TABSSQLGenerator }

function TAbsoluteDBSQLGenerator.FieldTypeToSQL(FieldDef: TSQLFieldDefinition): string;
var
  sAbsType: string;
begin
  case FieldDef.FieldType of
    ftBlob, ftDBaseOle, ftParadoxOle, ftTypedBinary:
      sAbsType := 'BLOB';
    ftBoolean:
      sAbsType := 'BOOLEAN';
    ftCurrency:
      sAbsType := 'CURRENCY';
    ftDateTime:
      sAbsType := 'DATETIME';
    ftFloat, ftSingle, ftExtended:
      sAbsType := 'FLOAT';
    ftGuid:
      sAbsType := 'GUID';
    ftLargeint:
      sAbsType := 'LARGEINT';
    ftMemo:
      sAbsType := 'MEMO';
    ftWideMemo:
      sAbsType := 'WIDEMEMO';
    ftWideString, ftFixedWideChar:
      sAbsType := Format('WIDESTRING(%d)', [FieldDef.Length]);
  else
    sAbsType := inherited FieldTypeToSQL(FieldDef);
  end;

  if FieldDef.AutoGenerated then
    Result := Result + ' AUTOINC(' + sAbsType + ')'
  else
    Result := sAbsType;
end;

function TAbsoluteDBSQLGenerator.GenerateCreateTable(Command: TCreateTableCommand): string;
var
  I: Integer;
  PkName: string;
begin
  Result := 'CREATE TABLE ';

  Result := Result + Command.Table.Name + ' ('#13#10'  ';

  for I := 0 to Command.Fields.Count - 1 do
  begin
    if I > 0 then
      Result := Result + ','#13#10'  ';
    Result := Result + GenerateFieldDefinition(Command.Fields[I]);
  end;

  // Primary Key
  if Command.IdFields.Count > 0 then
  begin
    PkName := 'PK_';
    PkName := PkName + Command.Table.Name;
    PkName := Copy(PkName, 1, GetMaxConstraintNameLength);
    Result := Result + ','#13#10 + '  ' + GeneratePrimaryKey(PkName, Command.IdFields);
  end;

  // Unique Constraints
  for I := 0 to Command.UniqueConstraints.Count - 1 do
  begin
    Result := Result + ','#13#10'  ' + GenerateUniqueKeyDefinition(Command.UniqueConstraints[I]);
  end;

  Result := Result + ');';
end;

function TAbsoluteDBSQLGenerator.GenerateEnableForeignKeys(Command: TEnableForeignKeysCommand): string;
begin
  {Absolute Database has no foreign keys.
  Before dropping a table, Aurelius offers the following strategies:
  - create an 'ALTER TABLE ... DROP CONSTRAINT ...' SQL command, to drop foreign keys;
  - disable foreign keys before dropping tables then enable foreign keys again (as in Aurelius.SQL.SQLite).
  We have chosen the second solution so we need a placeholder.
  As there is no 'NULL' SQL command in Absolute Database, we use a SQL command with no effect.}
  Result := NULL_SQL_COMMAND
end;

function TAbsoluteDBSQLGenerator.GenerateGetLastInsertId(SQLField: TSQLField): string;
begin
  Result := 'SELECT LastAutoinc(' + SQLField.Table.Name + ', ' + SQLField.Field + ') FROM ' + SQLField.Table.Name;
end;

function TAbsoluteDBSQLGenerator.GenerateLimitedSelect(SelectSql: TSelectSql;
  Command: TSelectCommand): string;
var
  MaxRows: integer;
  p: integer;
  TopStr: string;
begin
  Result := GenerateRegularSelect(SelectSql);
  p := Pos('SELECT', UpperCase(Result));
  Assert(p > 0, 'SELECT word not found in SQL. Cannot generate limited select');
  p := p + Length('SELECT');

  // MaxRows must be present in SQL statement no matter what
  if not Command.HasMaxRows then
    MaxRows := MaxInt div 2 // for some reason even maxint - 2 cause integer overflow
  else
    MaxRows := Command.MaxRows;

  if Command.HasFirstRow then
    TopStr := TopStr + Format('TOP %d,%d', [MaxRows, Command.FirstRow + 1])
  else
    TopStr := TopStr + Format('TOP %d', [MaxRows]);
  TopStr := ' ' + TopStr;
  Result := 'SELECT ' + TopStr + Copy(Result, p, MaxInt);
end;

function TAbsoluteDBSQLGenerator.GeneratePrimaryKey(APkName: string; AFields: TList<string>): string;
begin
  Result := 'PRIMARY KEY ' + APkName + ' (';
  Result := Result + TUtils.ConcatStrings(AFields, ', ');
  Result := Result + ')';
end;

function TAbsoluteDBSQLGenerator.GenerateUniqueKeyDefinition(Command: TCreateUniqueKeyCommand): string;
begin
  Result := 'UNIQUE INDEX ' + GetUniqueKeyName(Command) + ' (' +
    TUtils.ConcatStrings(Command.Fields, ', ') + ')';
end;

function TAbsoluteDBSQLGenerator.GetGeneratorName: string;
begin
  Result := 'AbsoluteDB SQL Generator';
end;

function TAbsoluteDBSQLGenerator.GetMaxConstraintNameLength: Integer;
begin
  Result := 255; // Identifier max length (in characters)
end;

function TAbsoluteDBSQLGenerator.GetSqlDialect: string;
begin
  Result := 'AbsoluteDB';
end;

function TAbsoluteDBSQLGenerator.GetSupportedFeatures: TDBFeatures;
begin
  Result := AllDBFeatures - [TDBFeature.Sequences, TDBFeature.AlterTableForeignKey];
end;

function TAbsoluteDBSQLGenerator.GetSupportedFieldTypes: TFieldTypeSet;
begin
//  Result := inherited GetSupportedFieldTypes + [ftGuid];
  Result := inherited GetSupportedFieldTypes + [ftBoolean];
end;

initialization
  TSQLGeneratorRegister.GetInstance.RegisterGenerator(TAbsoluteDBSQLGenerator.Create);

end.
