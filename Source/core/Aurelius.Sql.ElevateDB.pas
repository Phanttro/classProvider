unit Aurelius.Sql.ElevateDB;

interface

uses
  DB,
  Aurelius.Sql.AnsiSqlGenerator,
  Aurelius.Sql.BaseTypes,
  Aurelius.Sql.Commands,
  Aurelius.Sql.Interfaces,
  Aurelius.Sql.Register;

type
  TElevateDBSQLGenerator = class(TAnsiSQLGenerator)
  protected
    function GetMaxConstraintNameLength: Integer; override;
    function FieldTypeToSQL(FieldDef: TSQLFieldDefinition): string; override;
    function GetSqlLiteral(AValue: Variant; AType: TFieldType): string; override;
    function GetGeneratorName: string; override;
    function GetSqlDialect: string; override;
    function GetSupportedFeatures: TDBFeatures; override;
    function GenerateGetLastInsertId(SQLField: TSQLField): string; override;
    function GenerateDropField(Command: TDropFieldCommand): string; override;
    function GenerateLimitedSelect(SelectSql: TSelectSql; Command: TSelectCommand): string; override;

    function GetSupportedFieldTypes: TFieldTypeSet; override;
  end;

implementation

uses
  Variants, SysUtils;

{ TElevateDBSQLGenerator }

function TElevateDBSQLGenerator.FieldTypeToSQL(
  FieldDef: TSQLFieldDefinition): string;
begin
  Result := NumericTypeToSQL(FieldDef);
  if Result <> '' then
  begin
    // Ignore Precision and Scale if Scale > 4 (not supported by ElevateDB)
    // In this case, use a built-in numeric type to hold the specified scale
    if FieldDef.Scale >= 4 then
      Result := 'DOUBLE PRECISION';
    Exit;
  end;

  case FieldDef.FieldType of
    ftWideString:
      Result := Format('VARCHAR(%d)', [FieldDef.Length]);
    ftFixedWideChar:
      Result := Format('CHAR(%d)', [FieldDef.Length]);

    ftDateTime:
      Result := 'TIMESTAMP';
    ftBoolean:
      Result := 'BOOLEAN';

    ftMemo:
      Result := 'CLOB';
    ftWideMemo:
      Result := 'CLOB';
    ftBlob:
      Result := 'BLOB';
    ftGuid:
      Result := 'GUID'
  else
    Result := inherited FieldTypeToSql(FieldDef);
  end;
  if FieldDef.AutoGenerated then
    Result := Result + ' GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1)';
end;

function TElevateDBSQLGenerator.GenerateDropField(
  Command: TDropFieldCommand): string;
begin
  result := InternalGenerateDropField(Command, True);
end;

function TElevateDBSQLGenerator.GenerateGetLastInsertId(SQLField: TSQLField): string;
begin
  Result := Format('SELECT LASTIDENTITY(''%s'', ''%s'')',
    [SQLField.Table.Name, SQLField.Field]);

end;

function TElevateDBSQLGenerator.GenerateLimitedSelect(SelectSql: TSelectSql;
  Command: TSelectCommand): string;
begin
  Result := GenerateRegularSelect(SelectSql) + #13#10;
  if Command.HasMaxRows then
    Result := Result + Format('RANGE %d TO %d', [Command.FirstRow + 1, Command.LastRow + 1])
  else
    Result := Result + Format('RANGE %d', [Command.FirstRow + 1]);
end;

function TElevateDBSQLGenerator.GetSqlDialect: string;
begin
  Result := 'ElevateDB';
end;

function TElevateDBSQLGenerator.GetGeneratorName: string;
begin
  Result := 'ElevateDB SQL Generator';
end;

function TElevateDBSQLGenerator.GetMaxConstraintNameLength: Integer;
begin
  Result := 40;
end;

function TElevateDBSQLGenerator.GetSqlLiteral(AValue: Variant;
  AType: TFieldType): string;
begin
  Result := inherited GetSqlLiteral(AValue, AType);
end;

function TElevateDBSQLGenerator.GetSupportedFeatures: TDBFeatures;
begin
  Result := AllDBFeatures - [TDBFeature.Sequences];
end;

function TElevateDBSQLGenerator.GetSupportedFieldTypes: TFieldTypeSet;
begin
  Result := inherited GetSupportedFieldTypes;
  Result := Result + [ftBoolean, ftGuid];
end;

initialization
  TSQLGeneratorRegister.GetInstance.RegisterGenerator(TElevateDBSQLGenerator.Create);

end.
