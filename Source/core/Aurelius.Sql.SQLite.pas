unit Aurelius.Sql.SQLite;

{$I Aurelius.inc}

interface

uses
  DB,
  Aurelius.Sql.AnsiSqlGenerator,
  Aurelius.Sql.BaseTypes,
  Aurelius.Sql.Commands,
  Aurelius.Sql.Interfaces,
  Aurelius.Sql.Register;

type
  TSQLiteSQLGenerator = class(TAnsiSQLGenerator)
  public
    type
      TDateType = (Delphi, Julian, Text);
  private
    FDateType: TDateType;
  protected
    function GenerateGetLastInsertId(SQLField: TSQLField): string; override;

    function GetMaxConstraintNameLength: Integer; override;
    function FieldTypeToSQL(FieldDef: TSQLFieldDefinition): string; override;

    function GetGeneratorName: string; override;
    function GetSqlDialect: string; override;

    function GenerateDropField(Command: TDropFieldCommand): string; override;
    function GenerateLimitedSelect(SelectSql: TSelectSql; Command: TSelectCommand): string; override;

    function GetSupportedFeatures: TDBFeatures; override;

    // Disable/Enable foreign keys
    function GenerateEnableForeignKeys(Command: TEnableForeignKeysCommand): string; override;

    // Database compatibility methods
    function GetSupportedFieldTypes: TFieldTypeSet; override;
    function GetEquivalentFieldTypes: TFieldTypeEquivArray; override;
    function ConvertValue(Value: Variant; FromType, ToType: TFieldType): Variant; override;

    function GenerateCreateTable(Command: TCreateTableCommand): string; override;
  public
    property DateType: TDateType read FDateType write FDateType;
  end;

implementation
uses
  Variants, SysUtils, DateUtils, Generics.Collections,
  Aurelius.Global.Utils,
  Aurelius.Sql.Exceptions;

{ TSQLiteSQLGenerator }

function TSQLiteSQLGenerator.ConvertValue(Value: Variant; FromType,
  ToType: TFieldType): Variant;
var
  DateValue: TDateTime;
  DoubleValue: double;
begin
  if FromType in [ftDate, ftTime, ftDateTime] then
  begin
    // Convert from date to an alternative value
    case FDateType of
      TSQLiteSQLGenerator.TDateType.Julian:
        Result := DateTimeToJulianDate(VarToDateTime(Value));
      TSQLiteSQLGenerator.TDateType.Text:
        begin
          DateValue := VarToDateTime(Value);
          Result := TUtils.DateTimeToISO(DateValue);
        end;
    else
      //TSQLiteSQLGenerator.TDateType.Delphi:
        Result := VarAsType(Value, varDouble);
    end;
  end
  else
  if ToType in [ftDate, ftTime, ftDateTime] then
  begin
    // Try to convert a variant value to datetime
    // First check if the value is number or string
    if VarIsStr(Value) then
    begin
      Result := TUtils.ISOToDateTime(Value);
    end else
    begin
      // variant is not string, so it must be numeric
      DoubleValue := Value;
      if TryJulianDateToDateTime(DoubleValue, DateValue) then
        Result := DateValue
      else
        Result := TDateTime(DoubleValue);
    end;
  end
  else
    Result := inherited ConvertValue(Value, FromType, ToType);
end;

function TSQLiteSQLGenerator.FieldTypeToSQL(FieldDef: TSQLFieldDefinition): string;
begin
  Result := NumericTypeToSQL(FieldDef);
  if Result <> '' then
    Exit;

  case FieldDef.FieldType of
    ftShortint, ftByte, ftSmallint, ftWord, ftInteger, ftLongWord, ftLargeint:
      Result := 'INTEGER';
    ftCurrency, ftFloat, ftSingle, ftExtended:
      Result := 'REAL';
    ftBoolean{, ftFMTBcd}:
      Result := 'NUMERIC';
    ftString, ftWideString, ftFixedChar, ftFixedWideChar, ftMemo, ftWideMemo:
      Result := 'TEXT';
    ftBlob:
      Result := 'BLOB';
  else
    raise EUnsupportedFieldType.Create(Self, FieldDef.FieldType);
  end;

  if FieldDef.AutoGenerated then
    Result := Result + ' PRIMARY KEY AUTOINCREMENT';
end;

function TSQLiteSQLGenerator.GenerateCreateTable(Command: TCreateTableCommand): string;
var
  SavedIdFields: TList<string>;
  Field: TSQLFieldDefinition;
  HasAutoGenerated: boolean;
begin
  // If table has autoincrement field, then do not generate primary key
  HasAutoGenerated := false;
  for Field in Command.Fields do
    if Field.AutoGenerated then
    begin
      HasAutoGenerated := True;
      break;
    end;

  if not HasAutoGenerated then
  begin
    Result := inherited GenerateCreateTable(Command);
    Exit;
  end;

  // Call ancestor GenerateCreateTable by removing the primary key
  // Here we save and retrieve the removed primary key just in case, but I don't see a need or this
  // because Command is probably discarded after it's passed to GenerateCreateTable
  SavedIdFields := TList<string>.Create;
  try
    SavedIdFields.AddRange(Command.IdFields);
    Command.IdFields.Clear;
    try
      Result := inherited GenerateCreateTable(Command);
    finally
      Command.IdFields.AddRange(SavedIdFields);
    end;
  finally
    SavedIdFields.Free;
  end;
end;

function TSQLiteSQLGenerator.GenerateDropField(
  Command: TDropFieldCommand): string;
begin
  result := InternalGenerateDropField(Command, True);
end;

function TSQLiteSQLGenerator.GenerateEnableForeignKeys(
  Command: TEnableForeignKeysCommand): string;
begin
  if Command.Enable then
    Result := 'PRAGMA foreign_keys = on'
  else
    Result := 'PRAGMA foreign_keys = off';
end;

function TSQLiteSQLGenerator.GenerateGetLastInsertId(SQLField: TSQLField): string;
begin
  Result := 'SELECT last_insert_rowid()';
end;

function TSQLiteSQLGenerator.GenerateLimitedSelect(SelectSql: TSelectSql; Command: TSelectCommand): string;
var
  MaxRows: integer;
begin
  Result := GenerateRegularSelect(SelectSql) + #13#10;

  // MaxRows must be present in SQL statement no matter what
  if not Command.HasMaxRows then
    MaxRows := MaxInt
  else
    MaxRows := Command.MaxRows;

  if Command.HasFirstRow then
    Result := Result + Format('LIMIT %d OFFSET %d', [MaxRows, Command.FirstRow])
  else
    Result := Result + Format('LIMIT %d', [MaxRows]);
end;

function TSQLiteSQLGenerator.GetSqlDialect: string;
begin
  Result := 'SQLite';
end;

function TSQLiteSQLGenerator.GetEquivalentFieldTypes: TFieldTypeEquivArray;
var
  Arr: TFieldTypeEquivArray;
  c: Integer;
  EquivalentDateType: TFieldType;
begin
  Arr := inherited GetEquivalentFieldTypes;
  SetLength(Result, Length(Arr) + 3);

  case FDateType of
    TSQLiteSQLGenerator.TDateType.Julian:
      EquivalentDateType := ftFloat;
    TSQLiteSQLGenerator.TDateType.Text:
      EquivalentDateType := ftString;
  else
    //TSQLiteSQLGenerator.TDateType.Delphi:
      EquivalentDateType := ftFloat;
  end;

  Result[0].NotSupportedType := ftDate;
  Result[0].EquivalentType := EquivalentDateType;
  Result[1].NotSupportedType := ftTime;
  Result[1].EquivalentType := EquivalentDateType;
  Result[2].NotSupportedType := ftDateTime;
  Result[2].EquivalentType := EquivalentDateType;

  for c := 0 to Length(Arr) - 1 do
    Result[c + 3] := Arr[c];
end;

function TSQLiteSQLGenerator.GetGeneratorName: string;
begin
  Result := 'SQLite SQL Generator';
end;

function TSQLiteSQLGenerator.GetMaxConstraintNameLength: Integer;
begin
  Result := 30;
end;

function TSQLiteSQLGenerator.GetSupportedFeatures: TDBFeatures;
begin
  Result := AllDBFeatures - [TDBFeature.Sequences, TDBFeature.AlterTableForeignKey];
end;

function TSQLiteSQLGenerator.GetSupportedFieldTypes: TFieldTypeSet;
begin
  Result := inherited GetSupportedFieldTypes - [ftDate, ftTime, ftDateTime];
end;

initialization
  TSQLGeneratorRegister.GetInstance.RegisterGenerator(TSQLiteSQLGenerator.Create);

end.
