unit Aurelius.Sql.DB2;

{$I Aurelius.inc}

interface

uses
  DB,
  Aurelius.Sql.AnsiSqlGenerator,
  Aurelius.Sql.BaseTypes,
  Aurelius.Sql.Commands,
  Aurelius.Sql.Interfaces,
  Aurelius.Sql.Register;

type
  TDB2SQLGenerator = class(TAnsiSQLGenerator)
  protected
    function GetMaxConstraintNameLength: Integer; override;
    function FieldTypeToSQL(FieldDef: TSQLFieldDefinition): string; override;

    function GetGeneratorName: string; override;
    function GetSqlDialect: string; override;

    function GenerateGetLastInsertId(SQLField: TSQLField): string; override;

    function GenerateGetNextSequenceValue(Command: TGetNextSequenceValueCommand): string; override;
    function GenerateCreateSequence(Command: TCreateSequenceCommand): string; override;
    function GenerateDropSequence(Command: TDropSequenceCommand): string; override;
    function GenerateDropField(Command: TDropFieldCommand): string; override;
    function GenerateLimitedSelect(SelectSql: TSelectSql; Command: TSelectCommand): string; override;

    function GetSupportedFeatures: TDBFeatures; override;
  end;

implementation
uses
  Variants, SysUtils;

{ TDB2SQLGenerator }

function TDB2SQLGenerator.FieldTypeToSql(FieldDef: TSQLFieldDefinition): string;
begin
  Result := NumericTypeToSQL(FieldDef);
  if Result <> '' then
    Exit;

  case FieldDef.FieldType of
    ftLargeint:
      Result := 'BIGINT';
    ftMemo:
      Result := 'CLOB(1G)';
    ftWideMemo:
      Result := 'NCLOB(1G)';
    ftBlob:
      Result := 'BLOB(1G)';
  else
    Result := inherited FieldTypeToSql(FieldDef);
  end;

  if FieldDef.AutoGenerated then
    Result := Result + ' GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1)';
end;

function TDB2SQLGenerator.GenerateCreateSequence(Command: TCreateSequenceCommand): string;
begin
  Result := Format('CREATE SEQUENCE %s AS INTEGER START WITH %s INCREMENT BY %s;',
    [Command.SequenceName, IntToStr(Command.InitialValue), IntToStr(Command.Increment)]);
end;

function TDB2SQLGenerator.GenerateDropField(
  Command: TDropFieldCommand): string;
begin
  result := InternalGenerateDropField(Command, True);
end;

function TDB2SQLGenerator.GenerateDropSequence(Command: TDropSequenceCommand): string;
begin
  Result := Format('DROP SEQUENCE %s;', [Command.SequenceName]);
end;

function TDB2SQLGenerator.GenerateGetLastInsertId(SQLField: TSQLField): string;
begin
  Result := 'SELECT INTEGER(IDENTITY_VAL_LOCAL()) FROM SYSIBM.SYSDUMMY1;';
//  Result := 'SELECT CAST(IDENT_CURRENT('+QuotedStr(SQLTable.Name)+') AS INT)';
end;

function TDB2SQLGenerator.GenerateGetNextSequenceValue(Command: TGetNextSequenceValueCommand): string;
begin
  Result := Format('SELECT INTEGER(NEXT VALUE FOR %s) FROM SYSIBM.SYSDUMMY1;', [Command.SequenceName]);
end;

function TDB2SQLGenerator.GenerateLimitedSelect(SelectSql: TSelectSql;
  Command: TSelectCommand): string;
var
  RowNum: string;
  p: integer;
  SubSql: string;
  RowCondition: string;
begin
  // Build the rownum column
  RowNum := Format('ROW_NUMBER() OVER (%s) AS rownum, ', [SelectSql.OrderClause]);

  // Insert the rownum column in the select statement
  p := Pos('SELECT', UpperCase(SelectSql.SelectClause));
  Assert(p > 0, 'SELECT word not found in SQL. Cannot generate limited select');
  p := p + Length('SELECT');

  // Build the regular sql with the new added rownum column and without order clause
  SelectSql.SelectClause := 'SELECT ' + RowNum + Copy(SelectSql.SelectClause, p, MaxInt);
  SubSql := GenerateRegularSelect(SelectSql);

  // Build the filter condition for rows to be retrieved
  if Command.HasFirstRow and Command.HasMaxRows then
    RowCondition := Format('rownum BETWEEN %d AND %d', [Command.FirstRow + 1, Command.LastRow + 1])
  else
  if Command.HasFirstRow then
    RowCondition := Format('rownum >= %d', [Command.FirstRow + 1])
  else
    RowCondition := Format('rownum <= %d', [Command.LastRow + 1]);

  Result := 'SELECT * FROM ( '#13#10 +
    SubSql + ') as tempset '#13#10 +
    'WHERE ' + RowCondition;
end;

function TDB2SQLGenerator.GetSqlDialect: string;
begin
  Result := 'DB2';
end;

function TDB2SQLGenerator.GetGeneratorName: string;
begin
  Result := 'DB2 SQL Generator';
end;

function TDB2SQLGenerator.GetMaxConstraintNameLength: Integer;
begin
  Result := 128;
end;

function TDB2SQLGenerator.GetSupportedFeatures: TDBFeatures;
begin
  Result := AllDBFeatures;
end;

initialization
  TSQLGeneratorRegister.GetInstance.RegisterGenerator(TDB2SQLGenerator.Create);

end.
